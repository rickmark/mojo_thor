//------------------------------------------------------------------------------
// Types for /Users/rickmark/BootKernelCollection.development.kc.bin.bndb
//
// This header file generated by Binary Ninja 3.6.4811-dev
//------------------------------------------------------------------------------

#ifndef BN_TYPE_PARSER
#include <stdint.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdbool.h>
#include <wchar.h>

#define __packed
#define __noreturn
#define __convention(name)
#define __syscall(number)
#define __offset(...)
#define __padding
#define __named(name)
#define __inherited
#define __base(name, offset)
#define __ptr_offset(offset)
#define __data_var_refs
#define __vtable
typedef uint16_t wchar16;
typedef uint32_t wchar32;
#endif

//------------------------------------------------------------------------------
// Forward Declarations of Structures
//------------------------------------------------------------------------------

struct dyld_info;
struct dylib;
struct dylib_1;
struct dylib_command;
struct dynsymtab;
struct encryption_info;
struct fileset_entry_command;
struct linkedit_data;
struct load_command;
struct mach_header_64;
struct section;
struct section_64;
struct segment_command;
struct segment_command_64;
struct symtab;
struct uuid;
struct version_min;
//------------------------------------------------------------------------------
// Type Definitions
//------------------------------------------------------------------------------

// "cpu_type_t"
enum cpu_type_t : uint32_t
{
	CPU_TYPE_ANY = 0xffffffff,
	CPU_TYPE_VAX = 0x1,
	CPU_TYPE_MC680x0 = 0x6,
	CPU_TYPE_X86 = 0x7,
	CPU_TYPE_X86_64 = 0x1000007,
	CPU_TYPE_MIPS = 0x8,
	CPU_TYPE_MC98000 = 0xa,
	CPU_TYPE_HPPA = 0xb,
	CPU_TYPE_ARM = 0xc,
	CPU_TYPE_ARM64 = 0x100000c,
	CPU_TYPE_ARM64_32 = 0x200000c,
	CPU_TYPE_MC88000 = 0xd,
	CPU_TYPE_SPARC = 0xe,
	CPU_TYPE_I860 = 0xf,
	CPU_TYPE_ALPHA = 0x10,
	CPU_TYPE_POWERPC = 0x12,
	CPU_TYPE_POWERPC64 = 0x1000012
};

// "file_type_t"
enum file_type_t : uint32_t
{
	MH_OBJECT = 0x1,
	MH_EXECUTE = 0x2,
	MH_FVMLIB = 0x3,
	MH_CORE = 0x4,
	MH_PRELOAD = 0x5,
	MH_DYLIB = 0x6,
	MH_DYLINKER = 0x7,
	MH_BUNDLE = 0x8,
	MH_DYLIB_STUB = 0x9,
	MH_DSYM = 0xa,
	MH_KEXT_BUNDLE = 0xb,
	MH_FILESET = 0xc
};

// "flags_type_t"
enum flags_type_t : uint32_t
{
	MH_NOUNDEFS = 0x1,
	MH_INCRLINK = 0x2,
	MH_DYLDLINK = 0x4,
	MH_BINDATLOAD = 0x8,
	MH_PREBOUND = 0x10,
	MH_SPLIT_SEGS = 0x20,
	MH_LAZY_INIT = 0x40,
	MH_TWOLEVEL = 0x80,
	MH_FORCE_FLAT = 0x100,
	MH_NOMULTIDEFS = 0x200,
	MH_NOFIXPREBINDING = 0x400,
	MH_PREBINDABLE = 0x800,
	MH_ALLMODSBOUND = 0x1000,
	MH_SUBSECTIONS_VIA_SYMBOLS = 0x2000,
	MH_CANONICAL = 0x4000,
	MH_WEAK_DEFINES = 0x8000,
	MH_BINDS_TO_WEAK = 0x10000,
	MH_ALLOW_STACK_EXECUTION = 0x20000,
	MH_ROOT_SAFE = 0x40000,
	MH_SETUID_SAFE = 0x80000,
	MH_NO_REEXPORTED_DYLIBS = 0x100000,
	MH_PIE = 0x200000,
	MH_DEAD_STRIPPABLE_DYLIB = 0x400000,
	MH_HAS_TLV_DESCRIPTORS = 0x800000,
	MH_NO_HEAP_EXECUTION = 0x1000000,
	MH_APP_EXTENSION_SAFE = 0x2000000,
	MH_NLIST_OUTOFSYNC_WITH_DYLDINFO = 0x4000000,
	MH_SIM_SUPPORT = 0x8000000,
	MH_DYLIB_IN_CACHE = 0x80000000
};

// "load_command_type_t"
enum load_command_type_t : uint32_t
{
	LC_REQ_DYLD = 0x80000000,
	LC_SEGMENT = 0x1,
	LC_SYMTAB = 0x2,
	LC_SYMSEG = 0x3,
	LC_THREAD = 0x4,
	LC_UNIXTHREAD = 0x5,
	LC_LOADFVMLIB = 0x6,
	LC_IDFVMLIB = 0x7,
	LC_IDENT = 0x8,
	LC_FVMFILE = 0x9,
	LC_PREPAGE = 0xa,
	LC_DYSYMTAB = 0xb,
	LC_LOAD_DYLIB = 0xc,
	LC_ID_DYLIB = 0xd,
	LC_LOAD_DYLINKER = 0xe,
	LC_ID_DYLINKER = 0xf,
	LC_PREBOUND_DYLIB = 0x10,
	LC_ROUTINES = 0x11,
	LC_SUB_FRAMEWORK = 0x12,
	LC_SUB_UMBRELLA = 0x13,
	LC_SUB_CLIENT = 0x14,
	LC_SUB_LIBRARY = 0x15,
	LC_TWOLEVEL_HINTS = 0x16,
	LC_PREBIND_CKSUM = 0x17,
	LC_LOAD_WEAK_DYLIB = 0x80000018,
	LC_SEGMENT_64 = 0x19,
	LC_ROUTINES_64 = 0x1a,
	LC_UUID = 0x1b,
	LC_RPATH = 0x8000001c,
	LC_CODE_SIGNATURE = 0x1d,
	LC_SEGMENT_SPLIT_INFO = 0x1e,
	LC_REEXPORT_DYLIB = 0x8000001f,
	LC_LAZY_LOAD_DYLIB = 0x20,
	LC_ENCRYPTION_INFO = 0x21,
	LC_DYLD_INFO = 0x22,
	LC_DYLD_INFO_ONLY = 0x80000022,
	LC_LOAD_UPWARD_DYLIB = 0x80000023,
	LC_VERSION_MIN_MACOSX = 0x24,
	LC_VERSION_MIN_IPHONEOS = 0x25,
	LC_FUNCTION_STARTS = 0x26,
	LC_DYLD_ENVIRONMENT = 0x27,
	LC_MAIN = 0x80000028,
	LC_DATA_IN_CODE = 0x29,
	LC_SOURCE_VERSION = 0x2a,
	LC_DYLIB_CODE_SIGN_DRS = 0x2b,
	LC_ENCRYPTION_INFO_64 = 0x2c,
	LC_LINKER_OPTION = 0x2d,
	LC_LINKER_OPTIMIZATION_HINT = 0x2e,
	LC_VERSION_MIN_TVOS = 0x2f,
	LC_VERSION_MIN_WATCHOS = 0x30,
	LC_NOTE = 0x31,
	LC_BUILD_VERSION = 0x32,
	LC_DYLD_EXPORTS_TRIE = 0x80000033,
	LC_DYLD_CHAINED_FIXUPS = 0x80000034,
	LC_FILESET_ENTRY = 0x80000035
};

// "sg_flags_t"
enum sg_flags_t : uint32_t
{
	SG_HIGHVM = 0x1,
	SG_FVMLIB = 0x2,
	SG_NORELOC = 0x4,
	SG_PROTECTED_VERSION_1 = 0x8
};

// "vm_prot_t"
enum vm_prot_t : uint32_t
{
	VM_PROT_NONE = 0x0,
	VM_PROT_READ = 0x1,
	VM_PROT_WRITE = 0x2,
	VM_PROT_EXECUTE = 0x4,
	VM_PROT_NO_CHANGE = 0x8,
	VM_PROT_COPY_OR_WANTS_COPY = 0x10
};

// "section"
struct section
{
	char sectname[0x10];
	char segname[0x10];
	uint32_t addr;
	uint32_t size;
	uint32_t offset;
	uint32_t align;
	uint32_t reloff;
	uint32_t nreloc;
	uint32_t flags;
	uint32_t reserved1;
	uint32_t reserved2;
};

// "section_64"
struct section_64
{
	char sectname[0x10];
	char segname[0x10];
	uint64_t addr;
	uint64_t size;
	uint32_t offset;
	uint32_t align;
	uint32_t reloff;
	uint32_t nreloc;
	uint32_t flags;
	uint32_t reserved1;
	uint32_t reserved2;
	uint32_t reserved3;
};

// "va_list"
typedef void* va_list;

// "dylib"
struct dylib
{
	uint32_t name;
	uint32_t timestamp;
	uint32_t current_version;
	uint32_t compatibility_version;
};

// "dylib_1"
struct dylib_1
{
	uint32_t name;
	uint32_t timestamp;
	uint32_t current_version;
	uint32_t compatibility_version;
};

// "symtab"
struct symtab
{
	enum load_command_type_t cmd;
	uint32_t cmdsize;
	uint32_t symoff;
	uint32_t nsyms;
	uint32_t stroff;
	uint32_t strsize;
};

// "dynsymtab"
struct dynsymtab
{
	enum load_command_type_t cmd;
	uint32_t cmdsize;
	uint32_t ilocalsym;
	uint32_t nlocalsym;
	uint32_t iextdefsym;
	uint32_t nextdefsym;
	uint32_t iundefsym;
	uint32_t nundefsym;
	uint32_t tocoff;
	uint32_t ntoc;
	uint32_t modtaboff;
	uint32_t nmodtab;
	uint32_t extrefsymoff;
	uint32_t nextrefsyms;
	uint32_t indirectsymoff;
	uint32_t nindirectsyms;
	uint32_t extreloff;
	uint32_t nextrel;
	uint32_t locreloff;
	uint32_t nlocrel;
};

// "dyld_info"
struct dyld_info
{
	enum load_command_type_t cmd;
	uint32_t cmdsize;
	uint32_t rebase_off;
	uint32_t rebase_size;
	uint32_t bind_off;
	uint32_t bind_size;
	uint32_t weak_bind_off;
	uint32_t weak_bind_size;
	uint32_t lazy_bind_off;
	uint32_t lazy_bind_size;
	uint32_t export_off;
	uint32_t export_size;
};

// "uuid"
struct uuid
{
	enum load_command_type_t cmd;
	uint32_t cmdsize;
	uint8_t uuid[0x10];
};

// "linkedit_data"
struct linkedit_data
{
	enum load_command_type_t cmd;
	uint32_t cmdsize;
	uint32_t dataoff;
	uint32_t datasize;
};

// "dylib_command"
struct dylib_command
{
	enum load_command_type_t cmd;
	uint32_t cmdsize;
	struct dylib dylib;
};

// "mach_header_64"
struct mach_header_64
{
	uint32_t magic;
	enum cpu_type_t cputype;
	uint32_t cpusubtype;
	enum file_type_t filetype;
	uint32_t ncmds;
	uint32_t sizeofcmds;
	enum flags_type_t flags;
	uint32_t reserved;
};

// "encryption_info"
struct encryption_info
{
	enum load_command_type_t cmd;
	uint32_t cmdsize;
	uint32_t cryptoff;
	uint32_t cryptsize;
	uint32_t cryptid;
};

// "fileset_entry_command"
struct fileset_entry_command
{
	enum load_command_type_t cmd;
	uint32_t cmdsize;
	uint64_t vmaddr;
	uint64_t fileoff;
	uint32_t entry_id;
	uint32_t reserved;
};

// "segment_command"
struct segment_command
{
	enum load_command_type_t cmd;
	uint32_t cmdsize;
	char segname[0x10];
	uint32_t vmaddr;
	uint32_t vmsize;
	uint32_t fileoff;
	uint32_t filesize;
	enum vm_prot_t maxprot;
	enum vm_prot_t initprot;
	uint32_t nsects;
	enum sg_flags_t flags;
};

// "segment_command_64"
struct segment_command_64
{
	enum load_command_type_t cmd;
	uint32_t cmdsize;
	char segname[0x10];
	uint64_t vmaddr;
	uint64_t vmsize;
	uint64_t fileoff;
	uint64_t filesize;
	enum vm_prot_t maxprot;
	enum vm_prot_t initprot;
	uint32_t nsects;
	enum sg_flags_t flags;
};

// "load_command"
struct load_command
{
	enum load_command_type_t cmd;
	uint32_t cmdsize;
};

// "version_min"
struct version_min
{
	enum load_command_type_t cmd;
	uint32_t cmdsize;
	uint32_t version;
	uint32_t sdk;
};

